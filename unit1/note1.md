### init函数的使用
这个是包初始化的使用使用，可以初始化变量，init函数的优先级高于main函数

[markdown语法的操作地址](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)

### 基本类型
----
#### 布尔型
注意事项：在格式化输出时，你可以使用 %t 来表示你要输出
对于布尔值的好的命名能够很好地提升代码的可读性，例如以 is 或者 Is 开头的 isSorted、isFinished、isVisible

#### 整型和浮点型
在格式化字符串里，%d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0d 用于规定输出定长的整数，其中开头的数字 0 是必须的。

##### 类型转换
float类型转换int型的时候，小数点后的数字会丢弃
类型转换超出精度的的话，会引发panic

----

### 运算符
----

#### 二元运算符
二进制数中，最高位是0表示正数，1表示负数


负数的二进制的
```
1.先算出正数的二进制代码
2.然后按位去反
3.然后加1

示例如下：
5 的二进制求解过程：
0000 0101 ->获取对应的二进制
1111 1010 ->按位取反码

进行加1的操作如下：

1111 1010
0000 0001
1111 1011

最后-5的二进制是1111 1011

```

| 按位或 

1 ^ 0 -> 0
1 ^ 1 -> 1
0 ^ 1 -> 1
0 ^ 0 -> 0
示例如下：

```
1 ^ 2的结果是3
0001 ^ 0010 
```
& 按位与

0 ^ 1 -> 0
1 ^ 0 -> 0
0 ^ 1 -> 0
1 ^ 1 -> 1
示例如下：
```
1 & 2的结果是0
0001 & 0010
```

^ 按位异或

0 ^ 1 -> 1
0 ^ 0 -> 0
1 ^ 1 -> 0
1 ^ 0 -> 1
示例如下：
```
1 ^ 2的结果是3
0001 ^ 0010

```
位清除的概念所有的位置零 &^
x &^ y 

//这样理解的，以右边的位数为参考，ybit位为0的话，以xbit为主，ybit为1则为0

0000 &^ 0001 ->  输出位0
0001 &^ 0010 ->  输出是1

#### 一元操作符

^按位补足
无符号型的数是1
有符号的类型的数是-1
概念总结：按位补足是另外的按位异或
示例如下：
```
^2 = 10 ^ -01 = -11 = 3
^1 = 01 ^ -01 = -10 = -2
-2 = -10 ^ -01 = 1
-1 = -01 ^ -01 = 0
```
右移
bitP 的位向右移动 n 位，左侧空白部分使用 0 填充；如果 n 等于 2，则结果是当前值除以 2 的 n 次方。
示例如下：
```
3 >> 1 
0000 0011 ->右移1位
结果是：

0000 0001

```
左移
bitP 的位向左移动 n 位，右侧空白部分使用 0 填充；如果 n 等于 2，则结果是 2 的相应倍数，即 2 的 n 次方
示例如下：
```
3<<2 
0000 0011 ->左移以后的结果
0000 1100 
```

#### 字符类型

byte类型是unit8的别称，byte的长度是0-127
 示例：
```
var ch1 byte = 61
var ch2 byte = '\3C'
两者是一样的
```
unicode(utf-8)
包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）：

判断是否为字母：unicode.IsLetter(ch)
判断是否为数字：unicode.IsDigit(ch)
判断是否为空白符号：unicode.IsSpace(ch)
这些函数返回一个布尔值。
包utf8 拥有更多与 rune 相关的函数。


#### string
备注：string在拼接的时候，推荐使用strings.Join()或者字节缓冲（bytes.Buffer）拼接















